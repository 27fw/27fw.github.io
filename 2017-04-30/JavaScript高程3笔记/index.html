<!DOCTYPE html><html lang="zh-Hans"><head><meta charset="utf-8"><meta name="X-UA-Compatible" content="IE=edge"><title>JavaScript高程3笔记 | firework's Studio</title><meta name="description" content="JavaScript高程3笔记 - Wee"><meta name="viewport" content="width=device-width, initial-scale=1"><link rel="icon" href="/favicon.ico"><link rel="stylesheet" href="/css/theme.css"><link rel="search" type="application/opensearchdescription+xml" href="/atom.xml" title="firework's Studio"></head><body><div class="wrap"><header><h1 class="branding"><a href="/" title="firework's Studio">firework's Studio</a></h1><ul class="nav nav-list"><li class="nav-list-item"><a class="nav-list-link" href="/" target="_self">HOME</a></li><li class="nav-list-item"><a class="nav-list-link" href="/archives/index.html" target="_self">ARCHIVES</a></li><li class="nav-list-item"><a class="nav-list-link" href="/about" target="_self">ABOUT</a></li><li class="nav-list-item"><a class="nav-list-link" href="/atom.xml" target="_self">RSS</a></li></ul></header><main class="container"><div class="post"><article class="post-block"><h1 class="post-title">JavaScript高程3笔记</h1><div class="post-info">04/30</div><div class="post-content"><h2 id="Chapter1"><a href="#Chapter1" class="headerlink" title="Chapter1"></a>Chapter1</h2><h3 id="1-2"><a href="#1-2" class="headerlink" title="1.2"></a>1.2</h3><h4 id="1-2-2"><a href="#1-2-2" class="headerlink" title="1.2.2"></a>1.2.2</h4><ul>
<li><blockquote>
<p>DOM核心（DOM Core）和DOM HTML。其中，DOM核心规定的是如何映射基于XML的文档结构，以便简化对文档中任意部分的访问和操作。 DOM HTML模块则在DOM核心的基础上加以扩展，添加了针对HTML的对象和方法。</p>
</blockquote>
</li>
</ul>
<ul>
<li><blockquote>
<p>DOM2 级在原来 DOM 的基础上又扩充了（DHTML 一直都支持的）鼠标和用户界面事件、范围、遍历（迭代 DOM文档的方法）等细分模块，而且通过对象接口增加了对 CSS（Cascading Style Sheets，层叠样式表）的支持。 DOM1 级中的 DOM 核心模块也经过扩展开始支持 XML 命名空间。</p>
</blockquote>
</li>
<li><blockquote>
<p>DOM3 级则进一步扩展了 DOM，引入了以统一方式加载和保存文档的方法——在 DOM 加载和保存（DOM Load and Save）模块中定义；新增了验证文档的方法——在 DOM 验证（DOM Validation）模块中定义。 DOM3 级也对 DOM 核心进行了扩展，开始支持 XML 1.0 规范，涉及 XML Infoset、 XPath和 XML Base。</p>
</blockquote>
</li>
</ul>
<h3 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h3><ul>
<li><blockquote>
<p>JavaScript 是一种专为与网页交互而设计的脚本语言，由下列三个不同的部分组成： ECMAScript，由 ECMA-262 定义，提供核心语言功能； 文档对象模型（DOM），提供访问和操作网页内容的方法和接口； 浏览器对象模型（BOM），提供与浏览器交互的方法和接口。</p>
</blockquote>
</li>
</ul>
<h2 id="Chapter2"><a href="#Chapter2" class="headerlink" title="Chapter2"></a>Chapter2</h2><h3 id="2-3"><a href="#2-3" class="headerlink" title="2.3"></a>2.3</h3><ul>
<li><blockquote>
<p>如果在文档开始处没有发现文档类型声明，则所有浏览器都会默认开启混杂模式。但采用混杂模式不是什么值得推荐的做法，因为不同浏览器在这种模式下的行为差异非常大，如果不使用某些 hack 技术，跨浏览器的行为根本就没有一致性可言。</p>
</blockquote>
</li>
</ul>
<h2 id="Chapter-3"><a href="#Chapter-3" class="headerlink" title="Chapter 3"></a>Chapter 3</h2><h3 id="3-4"><a href="#3-4" class="headerlink" title="3.4"></a>3.4</h3><ul>
<li><blockquote>
<p>只要意在保存对象的变量还没有真正保存对象，就应该明确地让该变量保存<code>null</code>值。这样做不仅可以体现<code>null</code>作为空对象指针的惯例，而且也有助于进一步区分<code>null</code>和<code>undefined</code>。</p>
</blockquote>
</li>
<li>由于IEEE754数值浮点计算的通病，浮点数的计算并不是完全精确的，可加一个很小的<code>EPISION</code>来控制。</li>
<li>事实上，只有<code>0/0</code>才会返回<code>NaN</code>，正负数除以<code>0</code>会返回对应的<code>Infinity</code></li>
<li><img src="/2017-04-30/JavaScript高程3笔记/number.png" alt="number"></li>
<li><blockquote>
<p>在对非数值应用一元加操作符时，该操作符会像 Number()转型函数一样对这个值执行转换。</p>
</blockquote>
</li>
<li><blockquote>
<p>这个属性返回的字符数包括 16 位字符的数目。如果字符串中包含双字节字符，那么 length 属性可能不会精确地返回字符串中的字符数目。</p>
</blockquote>
</li>
</ul>
<p><code>.lenghth</code>会将单双字节字符都算作一个字符对待，英文和符号属于单字节字符，汉字等属于双字符字节，可以通过<code>&quot;abc&quot;.replace( /[^\x00-\xff]/g,&quot;aa&quot; ).length</code>匹配双字节，计算正确的length(要声明<code>&lt;meta charset=&quot;UTF-8&quot;&gt;</code>，否则结果会比较奇怪)。</p>
<ul>
<li><code>null</code>和<code>undefined</code>没有<code>toString()</code>, 在不知道要转换的是否为<code>null</code>或<code>undefined</code>时,可以使用<code>String()</code>转换函数,如果为<code>null</code>或<code>undefined</code>,会输出<code>&quot;null&quot;</code>和”<code>undefined&quot;</code>,否则调用对象的<code>toString()</code>方法.</li>
</ul>
<h3 id="3-5"><a href="#3-5" class="headerlink" title="3.5"></a>3.5</h3><ul>
<li><blockquote>
<p>按位非操作的本质:操作数的负数减1</p>
</blockquote>
</li>
<li><code>&gt;&gt;&gt;</code>无符号右移的操作数如果是负数,会变成正数,而且往往比较大.因为负数以其绝对值的二进制的补码表示.</li>
<li><code>&amp;&amp;</code><ul>
<li>如果第一个操作数是对象,则返回第二个操作数</li>
<li>如果第一个操作数为<code>true</code>,且第二个操作数是对象,则返回第二个对象.</li>
<li>如果都是对象,则返回第二个.</li>
<li>如果有个操作数是<code>null</code> <code>undefined</code> <code>NaN</code>则返回<code>null</code> <code>undefined</code> <code>NaN</code>.</li>
<li><strong>如果第一个操作数的求值结果为<code>true</code>，则返回第二个操作数</strong></li>
</ul>
</li>
<li><code>||</code><ul>
<li>如果第一个操作数是对象,则返回第一个</li>
<li><strong>如果第一个操作数的求值结果为<code>false</code>，则返回第二个操作数</strong></li>
<li>如果两个操作数都是对象,则返回第一个</li>
<li>如果两个操作数都是<code>null</code> <code>undefined</code> <code>NaN</code>则返回<code>null</code> <code>undefined</code> <code>NaN</code>.</li>
<li>逻辑或可以用来避免为变量赋<code>null</code>或<code>undefined</code>, 比如<code>var obj = preferredObj || backupObj</code></li>
</ul>
</li>
<li><p>​</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line"><span class="literal">Infinity</span> * <span class="number">-5</span> = - <span class="literal">Infinity</span>;</div><div class="line"><span class="literal">Infinity</span> * <span class="number">0</span> = <span class="literal">NaN</span>;</div><div class="line"><span class="literal">Infinity</span> / <span class="literal">Infinity</span> = <span class="literal">NaN</span>;</div><div class="line"><span class="number">0</span> / <span class="number">0</span> = <span class="literal">NaN</span>;</div><div class="line"><span class="number">5</span> / <span class="number">0</span> = <span class="literal">Infinity</span>; </div><div class="line"><span class="number">3</span> / <span class="literal">Infinity</span> = <span class="number">0</span>;</div><div class="line"><span class="literal">Infinity</span> / <span class="number">0</span> = <span class="literal">Infinity</span>;</div></pre></td></tr></table></figure>
</li>
<li><p>​</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="number">5</span> % <span class="literal">Infinity</span> = <span class="literal">NaN</span>;</div><div class="line"><span class="number">0</span> % <span class="literal">Infinity</span> = <span class="literal">NaN</span>;</div><div class="line"><span class="literal">Infinity</span> % <span class="literal">Infinity</span> = <span class="literal">NaN</span>;</div><div class="line"><span class="number">5</span> % <span class="number">0</span> = <span class="number">0</span>;</div></pre></td></tr></table></figure>
</li>
<li><p>​</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="literal">Infinity</span> - <span class="literal">Infinity</span> = <span class="literal">NaN</span>;</div><div class="line">+<span class="number">0</span> - <span class="number">0</span> = +<span class="number">0</span>;</div><div class="line"><span class="number">-0</span> - (<span class="number">-0</span>) = +<span class="number">0</span>;</div></pre></td></tr></table></figure>
</li>
<li><p><code>+</code>: </p>
<blockquote>
<p>如果有一个操作数是对象、数值或布尔值，则调用它们的<code>toString()</code>方法取得相应的字符串值，然后再应用前面关于字符串的规则。对于<code>undefined</code>和<code>null</code>，则分别调用<code>String()</code>函数并取得字符串<code>&quot;undefined&quot;</code>和<code>&quot;null&quot;</code>。</p>
</blockquote>
</li>
<li><code>-</code>: <blockquote>
<p>如果有一个操作数是对象，则调用对象的<code>valueOf()</code>方法以取得表示该对象的数值。如果得到的值是<code>NaN</code>，则减法的结果就是<code>NaN</code>。如果对象没有<code>valueOf()</code>方法，则调用其<code>toString()</code>方法并将得到的字符串转换为数值。</p>
</blockquote>
</li>
<li><code>&gt;</code> <code>&lt;</code> <code>&gt;=</code> <code>&lt;=</code><blockquote>
<p>如果两个操作数都是字符串，则比较两个字符串对应的字符编码值。<br>如果一个操作数是数值，则将另一个操作数转换为一个数值，然后执行数值比较。<br>如果一个操作数是对象，则调用这个对象的<code>valueOf()</code>方法，用得到的结果按照前面的规则执行比较。如果对象没有<code>valueOf()</code>方法，则调用<code>toString()</code>方法，并用得到的结果根据前面的规则执行比较。<br>如果一个操作数是布尔值，则先将其转换为数值，然后再执行比较。<br>任何操作数与<code>NaN</code>进行关系比较，结果都是<code>false</code>。</p>
</blockquote>
</li>
<li><code>==</code><blockquote>
<p>如果一个操作数是字符串，另一个操作数是数值，在比较相等性之前先将字符串转换为数值；<br>如果一个操作数是对象，另一个操作数不是，则调用对象的 valueOf()方法，用得到的基本类型值按照前面的规则进行比较；<br><code>null</code>和<code>undefined</code>是相等的。<br> 要比较相等性之前，不能将<code>null</code>和<code>undefined</code>转换成其他任何值。<br>由于相等和不相等操作符存在类型转换问题，而为了保持代码中数据类型的完整性，我们推荐使用全等和不全等操作符。</p>
</blockquote>
</li>
<li>ES5之前<code>for in</code>遇到<code>null</code>或<code>undefined</code>会报错,ES5修正了这个错误,如果需要兼容.先检测确认该对象的值不是<code>null</code>或<code>undefined</code>。</li>
<li><blockquote>
<p>由于大量使用<code>with</code>语句会导致性能下降，同时也会给调试代码造成困难，因此在开发大型应用程序时，不建议使用<code>with</code>语句。</p>
</blockquote>
</li>
<li>在使用<code>switch</code>时的<code>case</code>可以为表达式或各种类型不同的数据.</li>
<li><blockquote>
<p><code>return</code>语句也可以不带有任何返回值。在这种情况下，函数在停止执行后将返回 <code>undefined</code>值。建议要么始终返回一个值,要么就直接<code>return</code>.</p>
</blockquote>
</li>
<li><code>arguments</code>和参数的值时刻保持同步,修改其中一个就会同步另一个,如果传入的是对象,他们占用的其实还是同一片内存空间. </li>
<li><code>arguments</code>数组的长度是由传入的参数的个数决定的,所以如果只传入一个参数,但是修改<code>arguments[1]</code>也只会修改一个不存在的值,<code>arguments</code>的长度像<code>array</code>一样可以随意修改.</li>
<li>在严格模式下,对<code>arguments</code>的修改不会再同步到参数上,反过来也不会同步.<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">test</span>(<span class="params">a1, a2, a3</span>)</span>&#123;</div><div class="line">	<span class="built_in">console</span>.log(a2); <span class="comment">//5</span></div><div class="line">	<span class="built_in">console</span>.log(<span class="built_in">arguments</span>[<span class="number">1</span>]); <span class="comment">//5</span></div><div class="line">	a2 = <span class="number">99</span>;</div><div class="line">	<span class="built_in">console</span>.log(a2); <span class="comment">//99</span></div><div class="line">	<span class="built_in">console</span>.log(<span class="built_in">arguments</span>[<span class="number">1</span>]); <span class="comment">//5</span></div><div class="line">&#125;</div><div class="line"></div><div class="line">test(<span class="number">3</span>, <span class="number">5</span>);</div></pre></td></tr></table></figure>
</li>
</ul>
<h2 id="Chapter-4"><a href="#Chapter-4" class="headerlink" title="Chapter 4"></a>Chapter 4</h2><h3 id="4-1"><a href="#4-1" class="headerlink" title="4.1"></a>4.1</h3><ul>
<li><blockquote>
<p>ECMAScript 中所有函数的参数都是按值传递的。  </p>
</blockquote>
</li>
</ul>
<p>先看两个例子<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> animals = &#123;</div><div class="line">	mammals : &#123;</div><div class="line">		dog : <span class="number">1</span>,</div><div class="line">		cat : <span class="number">2</span></div><div class="line">	&#125;,</div><div class="line">	others : <span class="string">"999"</span></div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">changeAnimal</span>(<span class="params">obj</span>)</span>&#123;</div><div class="line">	obj.mammals = <span class="string">"no mammals"</span>;</div><div class="line">&#125;</div><div class="line"></div><div class="line">changeAnimal(animals);</div><div class="line"><span class="built_in">console</span>.log(animals.mammals);<span class="comment">//no mammals</span></div></pre></td></tr></table></figure></p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> animals = &#123;</div><div class="line">	mammals: &#123;</div><div class="line">		dog: <span class="number">1</span>,</div><div class="line">		cat: <span class="number">2</span></div><div class="line">	&#125;,</div><div class="line">	others: <span class="string">"999"</span></div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">changeAnimal</span>(<span class="params">obj</span>) </span>&#123;</div><div class="line">	obj = &#123;</div><div class="line">		mammals: &#123;</div><div class="line">			rabbit : <span class="number">3</span>,</div><div class="line">			pig: <span class="number">4</span></div><div class="line">		&#125;,</div><div class="line">		others: <span class="string">"666"</span></div><div class="line">	&#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line">changeAnimal(animals);</div><div class="line"><span class="built_in">console</span>.log(animals.mammals);<span class="comment">//Object &#123;dog: 1, cat: 2&#125;</span></div></pre></td></tr></table></figure>
<p>怎么理解按值传递,可以将其理解为C++的指针,相当于<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">Animal* animals = <span class="keyword">new</span> Animals()</div></pre></td></tr></table></figure></p>
<p>我们平时操作的都是这个指针对象.当函数传递一个对象的时候,实际上传递的是一个指针对象的深拷贝,两个指针占用内存独立,但指向同一块内存的对象.</p>
<p>在上面的第一个例子中,传入的<code>obj</code>参数是新建立的指向<code>animals</code>的指针,对其进行的操作相当于C++中的<code>obj-&gt;mammals =</code>,所以成功的修改了<code>animals</code>的值.<br>在第二个例子中,进入<code>changeAnimal</code>函数,<code>obj</code>依旧是新建立的指向<code>animals</code>的指针,但是随后的操作其实是将<code>obj</code>指向了新生成的匿名对象,相当于<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">changeAnimal</span>(<span class="params">obj</span>) </span>&#123;</div><div class="line">	<span class="keyword">var</span> newAnimal = &#123;</div><div class="line">		mammals: &#123;</div><div class="line">			rabbit : <span class="number">3</span>,</div><div class="line">			pig: <span class="number">4</span></div><div class="line">		&#125;,</div><div class="line">		others: <span class="string">"666"</span></div><div class="line">	&#125;</div><div class="line">	obj = newAnimal;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>最后一句<code>obj = newAnimal</code>, 其实就是两个指针之间的赋值了,<code>newAnimal</code>是指向<code>newAnimal</code>对象的指针,将它赋值给了<code>obj</code>,<code>obj</code>就是指向新的对象了,<code>obj</code>所指的<code>animals</code>还没有被动过,但<code>obj</code>从此切断了与原来的<code>animals</code>的关系,在离开这个函数作用域的时候,<code>newAnimal</code>连同<code>obj</code>会被一起回收掉.</p>
<ul>
<li><blockquote>
<p>垃圾收集器在运行的时候会给存储在内存中的所有变量都加上标记（当然，可以使用任何标记方式）。然后，它会去掉环境中的变量以及被环境中的变量引用的变量的标记。而在此之后再被加上标记的变量将被视为准备删除的变量，原因是环境中的变量已经无法访问到这些变量了。最后，垃圾收集器完成内存清除工作，销毁那些带标记的值并回收它们所占用的内存空间。</p>
</blockquote>
</li>
<li><p>IE9的<code>BOM</code>和<code>DOM</code>中的对象其实都是以<code>COM</code>对象的形式来实现的,而<code>COM</code>使用的是引用计数,所以如果<code>COM</code>发生了循环引用,需要使用<code>=null</code>切断引用.</p>
</li>
<li><blockquote>
<p>解除一个值的引用并不意味着自动回收该值所占用的内存。解除引用的真正作用是让值脱离执行环境，以便垃圾收集器下次运行时将其回收。</p>
</blockquote>
</li>
</ul>
<h2 id="Chapter-5"><a href="#Chapter-5" class="headerlink" title="Chapter 5"></a>Chapter 5</h2><h3 id="Array"><a href="#Array" class="headerlink" title="Array"></a>Array</h3><ul>
<li>使用<code>istanceof Array</code>会在网页中存在多个框架时出现问题,如果有多个框架,则有多个全局执行环境,则有多个<code>Array</code>的构造函数.当一个数组从一个框架传入另一个框架,再调用<code>istanceof</code>则不会是另一个框架的构造函数.ES5加入了<code>Array.isArray()</code>用来检测是否为<code>Array</code>.</li>
<li>数组的<code>toString()</code>会返回<code>,</code>分割的字符串,其中每一项分别调用了<code>toString()</code>,至于<code>valueOf()</code>,则返回原字符串.</li>
<li><code>sort</code>的<code>cmp</code>函数规则:如果第一个参数应该位于第二个之前则返回一个负数，如果两个参数相等则返回 <code>0</code>，如果第一个参数应该位于第二个之后则返回一个正数。</li>
<li>不给<code>concat()</code>输入参数可以快速的复制一个数组.</li>
<li><code>Array.indexOf()</code>和<code>Array.lastIndexOf()</code>在比较时使用的是<code>===</code></li>
<li><code>Array.reduce()</code>和<code>Array.reduceRight()</code>从第二(倒数第二)项开始.</li>
</ul>
<h3 id="Reg"><a href="#Reg" class="headerlink" title="Reg"></a>Reg</h3><ul>
<li><p>全局匹配<code>g</code>的时候,每次匹配会依次匹配所有的匹配项,当没有时,返回<code>null</code>再从头开始.</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> reg2 = <span class="regexp">/.a/g</span>;</div><div class="line"><span class="keyword">for</span> (<span class="keyword">var</span> i = <span class="number">0</span>; i &lt; <span class="number">10</span>; i++) &#123;</div><div class="line">  <span class="keyword">var</span> out = reg1.exec(<span class="string">"catastropathae"</span>);</div><div class="line">  <span class="built_in">console</span>.log(out)</div><div class="line">&#125;</div><div class="line"></div><div class="line">test.html:<span class="number">14</span> [<span class="string">"ca"</span>, <span class="attr">index</span>: <span class="number">0</span>, <span class="attr">input</span>: <span class="string">"catastropathae"</span>]</div><div class="line">test.html:<span class="number">14</span> [<span class="string">"ta"</span>, <span class="attr">index</span>: <span class="number">2</span>, <span class="attr">input</span>: <span class="string">"catastropathae"</span>]</div><div class="line">test.html:<span class="number">14</span> [<span class="string">"pa"</span>, <span class="attr">index</span>: <span class="number">8</span>, <span class="attr">input</span>: <span class="string">"catastropathae"</span>]</div><div class="line">test.html:<span class="number">14</span> [<span class="string">"ha"</span>, <span class="attr">index</span>: <span class="number">11</span>, <span class="attr">input</span>: <span class="string">"catastropathae"</span>]</div><div class="line">test.html:<span class="number">14</span> <span class="literal">null</span></div><div class="line">test.html:<span class="number">14</span> [<span class="string">"ca"</span>, <span class="attr">index</span>: <span class="number">0</span>, <span class="attr">input</span>: <span class="string">"catastropathae"</span>]</div><div class="line">test.html:<span class="number">14</span> [<span class="string">"ta"</span>, <span class="attr">index</span>: <span class="number">2</span>, <span class="attr">input</span>: <span class="string">"catastropathae"</span>]</div><div class="line">test.html:<span class="number">14</span> [<span class="string">"pa"</span>, <span class="attr">index</span>: <span class="number">8</span>, <span class="attr">input</span>: <span class="string">"catastropathae"</span>]</div><div class="line">test.html:<span class="number">14</span> [<span class="string">"ha"</span>, <span class="attr">index</span>: <span class="number">11</span>, <span class="attr">input</span>: <span class="string">"catastropathae"</span>]</div><div class="line">test.html:<span class="number">14</span> <span class="literal">null</span></div><div class="line">test.html:<span class="number">20</span> [<span class="string">"ca"</span>, <span class="attr">index</span>: <span class="number">0</span>, <span class="attr">input</span>: <span class="string">"catastropathae"</span>]</div></pre></td></tr></table></figure>
</li>
<li><p><code>toString()</code>和<code>toLocaleString()</code>都会返回正则表达式的字面量,与创建正则表达式的方式无关.<code>valueOf()</code>返回正则表达式自身.</p>
</li>
<li>使用<code>Reg.$1 - Reg.$9</code>可以访问存储的捕获组,这样即使<code>.test()</code>只返回布尔值,也可以获得捕获组.</li>
</ul>
<h3 id="Function"><a href="#Function" class="headerlink" title="Function"></a>Function</h3><ul>
<li><blockquote>
<p>函数是对象,函数名是指针,可以用<code>null</code>切断他们之间的联系.</p>
</blockquote>
</li>
<li>函数中有<code>arguments.callee</code>指向这个函数本身,可以应用在递归函数中,在严格模式下无法访问.</li>
<li><code>arguments.callee.caller</code>可以显示调用当前函数的函数的引用,在严格模式下无法访问.</li>
<li><code>toString()</code> <code>toLocaleString()</code> <code>valueOf()</code>都返回函数的代码.</li>
</ul>
<h3 id="基本类型"><a href="#基本类型" class="headerlink" title="基本类型"></a>基本类型</h3><ul>
<li>在对基本类型进行处理的时候,会隐式创建一个<code>String</code>,在处理完之后再立即销毁(指向<code>null</code>).所以其生命周期不可控.<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> s1 = <span class="string">"sss"</span>;</div><div class="line">s1.name = <span class="string">"sssName"</span>;</div><div class="line"><span class="built_in">console</span>.log(s1.name);<span class="comment">//undefined</span></div><div class="line"></div><div class="line"><span class="keyword">var</span> s2 = <span class="keyword">new</span> <span class="built_in">String</span>(<span class="string">"ssss"</span>);</div><div class="line">s2.name = <span class="string">"ssssName"</span>;</div><div class="line"><span class="built_in">console</span>.log(s2.name);<span class="comment">//ssssName</span></div></pre></td></tr></table></figure>
</li>
</ul>
<h4 id="Boolean"><a href="#Boolean" class="headerlink" title="Boolean"></a>Boolean</h4><ul>
<li>不建议使用,<code>Boolean</code>对象的实例是对象,但是对象的布尔运算都是<code>true</code>.</li>
</ul>
<h4 id="String"><a href="#String" class="headerlink" title="String"></a>String</h4><ul>
<li><blockquote>
<p><code>toFixed()</code>方法会按照指定的小数位返回数值的字符串表示.</p>
</blockquote>
</li>
<li><blockquote>
<p>可用于格式化数值的方法是<code>toExponential()</code>，该方法返回以指数表示法（也称 e 表示法）</p>
</blockquote>
</li>
<li><blockquote>
<p><code>toPrecision()</code>方法可能会返回固定大小（fixed）格式，也可能返回指数<br>（exponential）格式；具体规则是看哪种格式最合适。</p>
</blockquote>
</li>
<li><code>charCodeAt()</code>用来访问某个字符的ASCII码</li>
<li><code>replace()</code>的第二个参数可以是一个函数,参数依次是模式的匹配项,模式匹配项在字符串中的位置和原始字符串.返回一个字符串作为要替换的字符串.</li>
<li><code>split()</code>的第一个参数可以使正则表达式.</li>
<li><code>localeCompare()</code>返回的值取决于实现,所以在使用前应当确认好.</li>
<li><code>String.fromeCharCode()</code>将ASCII码转为字符串.</li>
</ul>
<h3 id="5-7"><a href="#5-7" class="headerlink" title="5.7"></a>5.7</h3><ul>
<li><code>encodeURI()</code>不会对本身属于URI的特殊字符进行编码,<code>encodeURIComponent()</code>则会对它发现的任何非标准字符进行编码.相反的操作是<code>decodeURI()</code>和<code>decodeURIComponent()</code></li>
<li>比如取1-10的整数,值 = <code>Math.floor(Math.random()</code> * <code>可能值的总数</code> + <code>第一个可能的值</code>.</li>
</ul>
<h2 id="Chapter-6"><a href="#Chapter-6" class="headerlink" title="Chapter 6"></a>Chapter 6</h2><h3 id="6-1"><a href="#6-1" class="headerlink" title="6.1"></a>6.1</h3><ul>
<li><blockquote>
<p>在调用<code>Object.defineProperty()</code>方法时，如果不指定，<code>configurable</code>、 <code>enumerable</code>和<code>writable</code>特性的默认值都是<code>false</code>。</p>
</blockquote>
</li>
<li><blockquote>
<p>一旦把属性定义为不可配置的，就不能再把它变回可配置了。此时，再调用<code>Object.defineProperty()</code>方法修改除 <code>writable</code>之外的特性，都会导致错误.</p>
</blockquote>
</li>
</ul>
<p>书上是这么写的,但事实真的是这样吗?<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> obj1 = &#123;</div><div class="line">  name: <span class="string">"111"</span></div><div class="line">&#125;;</div><div class="line"></div><div class="line"><span class="built_in">Object</span>.defineProperty(obj1, <span class="string">"name"</span>, &#123;</div><div class="line">  configurable: <span class="literal">false</span>,</div><div class="line">  writable: <span class="literal">true</span>,</div><div class="line">&#125;)</div><div class="line"></div><div class="line">obj1.name = <span class="string">"222"</span>;</div><div class="line"><span class="built_in">console</span>.log(obj1.name)<span class="comment">//222</span></div><div class="line"></div><div class="line"><span class="built_in">Object</span>.defineProperty(obj1, <span class="string">"name"</span>, &#123;</div><div class="line">  writable: <span class="literal">false</span>,</div><div class="line">&#125;)</div><div class="line">obj1.name = <span class="string">"333"</span>;</div><div class="line"><span class="built_in">console</span>.log(obj1.name)<span class="comment">//22</span></div></pre></td></tr></table></figure></p>
<p>可以看到,再<code>Configurable</code>被设置为<code>false</code>的情况下,可以将<code>writable</code>由<code>true</code>改为<code>false</code>,但是<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> obj1 = &#123;</div><div class="line">  name: <span class="string">"111"</span></div><div class="line">&#125;;</div><div class="line"></div><div class="line"><span class="built_in">Object</span>.defineProperty(obj1, <span class="string">"name"</span>, &#123;</div><div class="line">  configurable: <span class="literal">false</span>,</div><div class="line">  writable: <span class="literal">false</span>,</div><div class="line">&#125;)</div><div class="line"></div><div class="line">obj1.name = <span class="string">"222"</span>;</div><div class="line"><span class="built_in">console</span>.log(obj1.name)<span class="comment">//111</span></div><div class="line"></div><div class="line"><span class="built_in">Object</span>.defineProperty(obj1, <span class="string">"name"</span>, &#123;</div><div class="line">  writable: <span class="literal">true</span>,</div><div class="line">&#125;)</div><div class="line">obj1.name = <span class="string">"333"</span>;</div><div class="line"><span class="built_in">console</span>.log(obj1.name)<span class="comment">//test.html:24 Uncaught TypeError: Cannot redefine property: name</span></div></pre></td></tr></table></figure></p>
<p>却不能将<code>false</code>改为<code>true</code>,说明一但将<code>Configurable</code>属性设置为<code>false</code>之后,只能将属性的可配置属性往低改.另外,如果<code>Configurable</code>属性设置为<code>false</code>时改写<code>enumerable</code> <code>Writable</code>属性,如果改写前后同为<code>false</code>或同为<code>true</code>或者之前提到的将<code>Writable</code>由<code>true</code>变为<code>false</code>,则不会报错,否则会报错.</p>
<h3 id="6-2"><a href="#6-2" class="headerlink" title="6.2"></a>6.2</h3><ul>
<li><p>通过构造函数创建一个实例的过程要经过四个步骤:</p>
<blockquote>
<ol>
<li>创建一个新对象；</li>
<li>将构造函数的作用域赋给新对象（因此 this 就指向了这个新对象）；</li>
<li>执行构造函数中的代码（为这个新对象添加属性）；</li>
<li>返回新对象。</li>
</ol>
</blockquote>
</li>
<li><p>可以使用形如<code>var obj = {}; Person.call(obj);</code>来执行构造函数,因为<code>call</code>和<code>apply</code>的本质就是设置函数体内<code>this</code>的值.</p>
</li>
<li><blockquote>
<p>无论什么时候，只要创建了一个新函数，就会根据一组特定的规则为该函数创建一个 <code>prototype</code>属性，这个属性指向函数的原型对象。在默认情况下，所有原型对象都会自动获得一个<code>constructor</code>（构造函数）属性，这个属性包含一个指向<code>prototype</code>属性所在函数的指针。</p>
</blockquote>
</li>
<li><blockquote>
<p>ECMAScript 5 的<code>Object.getOwnPropertyDescriptor()</code>方法只能用于实例属性，要取得原型属性的描述符，必须直接在原型对象上调用<code>Object.getOwnPropertyDescriptor()</code>方法。</p>
</blockquote>
</li>
</ul>
<p>所以是说使用<code>getOwnPropertyDescriptor()</code>只能获得当前实例的属性,不能访问继承而来的属性.</p>
<ul>
<li><code>in</code>操作符可以返回对象是否具有某个属性,无论这个属性是实例具有的还是继承自原型,配合<code>hasOwnProperty()</code>可以判断属性是来自原型还是自有.</li>
<li><blockquote>
<p> 要取得对象上所有可枚举的<strong>实例</strong>属性，可以使用ECMAScript 5 的<code>Object.keys()</code>方法。这个方法接收一个对象作为参数，返回一个包含所有<strong>可枚举属性</strong>的字符串数组。</p>
</blockquote>
</li>
<li><blockquote>
<p>如果你想要得到所有实例属性，无论它是否可枚举，都可以使用 <code>Object.getOwnPropertyNames()</code>方法。</p>
</blockquote>
</li>
<li><code>instanceof</code>运算符用来判断一个构造函数的<code>prototype</code>属性所指向的对象是否存在另外一个要检测对象的原型链上,所以即使将<code>obj.constructor.prototype</code>重写,导致<code>prototype</code>的<code>constructor</code>不再指向构造函数,<code>instanceof</code>也可以正确的指示.</li>
<li>直接重写<code>prototype</code>会导致原本不可枚举的<code>constructor</code>属性变得可以枚举,可以在最后使用<code>Object.defineProperty()</code>来定义一个不可枚举的<code>constructor</code>.</li>
<li><blockquote>
<p>当调用构造函数创建一个新实例后，该实例的内部将包含一个指针（内部<br>属性），指向构造函数的原型对象。 即<code>[[Prototype]]</code></p>
</blockquote>
</li>
</ul>
<p>所以,在重写原型对象之后,老的实例所指向的原型对象仍然是老的原型对象,而不是新的.是不会动态更新的.</p>
<ul>
<li>寄生构造和稳妥寄生构造的区别就是,稳妥寄生构造创建的实例只有方法而没有属性,稳妥寄生构造的属性是通过定义在构造函数内部,通过闭包进行访问的.稳妥构造函数模式提供的这种安全性，使得它非常适合在某些安全执行环境下使用.<h3 id="6-3"><a href="#6-3" class="headerlink" title="6.3"></a>6.3</h3></li>
<li>借用构造函数<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">SuperType</span>(<span class="params">name</span>) </span>&#123;</div><div class="line">  <span class="keyword">this</span>.name = name;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">SubType</span>(<span class="params"></span>) </span>&#123;</div><div class="line">  <span class="comment">//继承了 SuperType，同时还传递了参数</span></div><div class="line">  SuperType.call(<span class="keyword">this</span>, <span class="string">"Nicholas"</span>);</div><div class="line">  <span class="comment">//实例属性</span></div><div class="line">  <span class="keyword">this</span>.age = <span class="number">29</span>;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="keyword">var</span> sub1 = <span class="keyword">new</span> SubType();</div><div class="line"><span class="built_in">console</span>.log(sub1 <span class="keyword">instanceof</span> SubType);<span class="comment">//true</span></div><div class="line"><span class="built_in">console</span>.log(sub1 <span class="keyword">instanceof</span> SuperType);<span class="comment">//false</span></div><div class="line"><span class="built_in">console</span>.log(<span class="built_in">Object</span>.getPrototypeOf(sub1) == SubType.prototype);<span class="comment">//true</span></div><div class="line"><span class="built_in">console</span>.log(<span class="built_in">Object</span>.getPrototypeOf(<span class="built_in">Object</span>.getPrototypeOf(sub1)) == <span class="built_in">Object</span>.prototype);<span class="comment">//true</span></div></pre></td></tr></table></figure>
</li>
</ul>
<p>可以看出<code>SuperType</code>已经不在<code>sub1</code>的原型链上了,所以<code>SubType</code>的实例只能调用<code>SuperType</code>构造函数中的方法,而无法继承<code>SuperType</code>的原型属性.</p>
<h2 id="Chapter-7"><a href="#Chapter-7" class="headerlink" title="Chapter 7"></a>Chapter 7</h2><h3 id="7-2"><a href="#7-2" class="headerlink" title="7.2"></a>7.2</h3><ul>
<li><blockquote>
<p>作用域链本质上是一个指向变量对象的指针列表，它只引用但不实际包含变量对象.</p>
</blockquote>
</li>
</ul>
<p>在<strong>创建</strong>局部函数时,会创建一个预先包含全局变量的作用域链,然后将这个作用域链保存在<strong>内部的<code>[[Scope]]</code>属性中</strong>.当<strong>调用</strong>局部函数时,会为函数创建一个执行环境,然后通过<strong>复制</strong>函数的<code>[[Scope]]</code>属性中的对象构建起<strong>执行环境的作用域链</strong>.此后,当有新的变量对象被创建会被推入<strong>执行环境作用域链的前端</strong>.</p>
<ul>
<li>闭包之所以能持续引用外部函数的变量,是因为闭包函数的作用域链中还在持续引用外部函数的活动对象.所以,此时外部函数的<strong>作用域链已经被销毁了</strong>,但活动对象扔能停留在内存中.</li>
<li>还是使用<code>null</code>接触对闭包的引用~</li>
<li><blockquote>
<p>JavaScript从来不会告诉你是否多次声明了同一个变量；遇到这种情况，它只会对后续的声明视而不见（不过，它会执行后续声明中的变量初始化）。</p>
</blockquote>
</li>
<li>使用立即执行函数可以模仿块级作用域,好处是因为没有指向匿名函数的引用.只要函数执行完毕,就可以立即销毁其作用域链了.</li>
</ul>
<h2 id="Chapter-10"><a href="#Chapter-10" class="headerlink" title="Chapter 10"></a>Chapter 10</h2><h3 id="10-1"><a href="#10-1" class="headerlink" title="10.1"></a>10.1</h3><ul>
<li>IE没有实现<code>Node</code>类型,所以无法通过访问类似<code>Node.ELEMENT_NODE</code>的常量来判断节点的类型,最好是用数字.<h4 id="Node对象的方法"><a href="#Node对象的方法" class="headerlink" title="Node对象的方法:"></a><code>Node</code>对象的方法:</h4><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">hasChildNodes() <span class="comment">//是否包含子节点</span></div><div class="line">ownDocument() <span class="comment">//指向文档的文档节点</span></div><div class="line">appendChild() <span class="comment">//如果节点已经存在于文档当中了,那么会将节点移动到新的位置</span></div><div class="line">replaceChild() <span class="comment">//替换节点,但被替换的节点还存留于文档中,只是没在文档树中</span></div><div class="line">removeChild() <span class="comment">//删除节点,被删节点同上</span></div><div class="line">cloneChild() <span class="comment">//接受一个参数,true为深复制,false为浅复制.这个方法不会复制节点上的事件,但在IE中会</span></div><div class="line">normalize() <span class="comment">//合并后代的相邻文本节点和删除空白文本节点</span></div></pre></td></tr></table></figure>
</li>
</ul>
<h5 id="Document对象的方法"><a href="#Document对象的方法" class="headerlink" title="Document对象的方法:"></a><code>Document</code>对象的方法:</h5><ul>
<li><blockquote>
<p><code>domain</code>: 如果域名一开始是“松散的”（loose），那么不能将它再设置为“紧绷的”（tight）</p>
</blockquote>
</li>
<li><code>HTMLCollection</code>对象有一个方法:<code>namedItem()</code>用来根据<code>name</code>获取对象,但与<code>getElementByName</code>不同的是,它只会返回第一个<code>name</code>符合要求的节点.</li>
<li>在IE中<code>getElementsByTagName()</code>会包含所有注释节点.</li>
<li><p>​</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="built_in">document</span>.anchors <span class="comment">//所有带name特性的&lt;a&gt;元素</span></div><div class="line"><span class="built_in">document</span>.applets <span class="comment">//所有&lt;applet&gt;元素,没用过这个标签,一脸懵逼</span></div><div class="line"><span class="built_in">document</span>.forms <span class="comment">//所有表单</span></div><div class="line"><span class="built_in">document</span>.images <span class="comment">//所有img元素</span></div><div class="line"><span class="built_in">document</span>.links <span class="comment">//所有得href特性的&lt;a&gt;元素</span></div></pre></td></tr></table></figure>
</li>
<li><blockquote>
<p>我们建议多数情况下，在使用DOM的某些特殊的功能之前，最好除了检测<code>hasFeature()</code>之外，还同时使用能力检测。</p>
</blockquote>
</li>
</ul>
<h5 id="Element类型"><a href="#Element类型" class="headerlink" title="Element类型:"></a><code>Element</code>类型:</h5><ul>
<li>在HTML中,标签名都是大写表示,再XML中标签名会与源码保持一致.所以最好在进行标签比较之前统一大小写.ex:<code>element.tagName.toLowerCase() == &quot;p&quot;</code></li>
<li><blockquote>
<p>特性的名称是不区分大小写的，即”ID”和”id”代表的都是同一个特性。另外也要注意，根据 HTML5 规范，自定义特性应该加上<code>data-</code>前缀以便验证。</p>
</blockquote>
</li>
<li><blockquote>
<p><code>Element</code>类型的<code>attributes</code>属性包含该节点所有的属性.</p>
</blockquote>
</li>
<li><code>Element</code>元素也支持<code>getElementsByTagName</code>这个方法.</li>
</ul>
<h5 id="Text类型"><a href="#Text类型" class="headerlink" title="Text类型:"></a><code>Text</code>类型:</h5><ul>
<li><code>Text</code>类型的<code>nodeValue</code>和<code>data</code>属性是等价的.</li>
<li><blockquote>
<p><code>appendData(text)</code>：将<code>text</code>添加到节点的末尾。</p>
</blockquote>
</li>
<li><blockquote>
<p><code>deleteData(offset, count)</code>：从<code>offset</code>指定的位置开始删除<code>count</code>个字符。</p>
</blockquote>
</li>
<li><blockquote>
<p><code>insertData(offset, text)</code>：在<code>offset</code>指定的位置插入<code>text</code>。</p>
</blockquote>
</li>
<li><blockquote>
<p><code>replaceData(offset, count, text)</code>：用<code>text</code>替换从<code>offset</code>指定的位置开始到<code>offset+count</code>为止处的文本。</p>
</blockquote>
</li>
<li><blockquote>
<p><code>splitText(offset)</code>：从<code>offset</code>指定的位置将当前文本节点分成两个文本节点。</p>
</blockquote>
</li>
<li><blockquote>
<p><code>substringData(offset, count)</code>：提取从<code>offset</code>指定的位置开始到<code>offset+count</code>为止处的字符串。</p>
</blockquote>
</li>
</ul>
<h5 id="Comment类型"><a href="#Comment类型" class="headerlink" title="Comment类型"></a><code>Comment</code>类型</h5><ul>
<li><blockquote>
<p><code>Comment</code>类型与<code>Text</code>类型继承自相同的基类，因此它拥有除<code>splitText()</code>之外的所有字符串操作方法。</p>
</blockquote>
</li>
<li><blockquote>
<p>另外，使用<code>document.createComment()</code>并为其传递注释文本也可以创建注释节点</p>
</blockquote>
</li>
</ul>
<h2 id="Chapter-11"><a href="#Chapter-11" class="headerlink" title="Chapter 11"></a>Chapter 11</h2><h3 id="11-1"><a href="#11-1" class="headerlink" title="11.1"></a>11.1</h3><ul>
<li><blockquote>
<p><code>querySelectorAll()</code>返回的值实际上是带有所有属性和方法的<code>NodeList</code>，而其底层实现则类似于一组元素的快照，而非不断对文档进行搜索的动态查询。</p>
<h3 id="11-3"><a href="#11-3" class="headerlink" title="11.3"></a>11.3</h3></blockquote>
</li>
<li><code>getElementsByClassName()</code>可以传递多个类名,使用空格分割,<code>Element</code>和<code>Document</code>都有这个方法.</li>
<li><code>classList</code>是<code>DomTokenList</code>的实例,有个<code>contains(value)</code>的属性,返回是否具有对应的类名.支持<code>classList</code>的浏览器是Firefox3.6+和Chrome.</li>
<li><code>document.activeElement</code>能返回DOM中获得焦点的元素的引用.文档刚加载完毕时<code>document.activeElement</code>指向<code>document.body</code></li>
<li><code>document.readyState</code>用来指示文档是否已经加载完毕.</li>
<li><code>document.compatMode</code>用来检测IE是在混杂模式还是在标准模式.</li>
<li>与<code>document.body</code>相对应的也有<code>document.head</code>属性.</li>
<li><code>document.charset</code>可以用来指定字符集.</li>
<li>通过在标签中添加<code>data-</code>开头的属性,就可以在元素的<code>dataset</code>属性中获得对应的属性(不包含<code>data-</code>前缀)</li>
<li><blockquote>
<p>不要指望所有浏览器返回的 innerHTML 值完全相同。</p>
</blockquote>
</li>
<li><code>insertAdjacentHTML()</code>可以像<code>innerHTML</code>一样插入HTML文本,第一个参数可以为以下之一<code>beforebegin</code> <code>afterbegin</code> <code>beforeend</code> <code>afterend</code></li>
<li>使用<code>innerHTML</code> <code>outerHTML</code> <code>insertAdjacentHTML</code>方法时,元素与对应的js事件的绑定关系并没有一并删除.</li>
<li>设置<code>innerHTML</code>或<code>outerHTML</code> 时，就会创建一个HTML解析器,所以过多次的调用会造成多次的创建和销毁HTML解析器,带来性能损失.</li>
<li><code>contains()</code>检测参数DOM是否为调用方法的DOM的子节点.相当于<code>compareDocumentPosition()</code></li>
<li><code>innerText</code>永远只会生成当前节点的一个文本节点,会对输入的HTML进行编码.利用这一点，可以通过<code>innerText</code>属性过滤掉HTML标签。方法是将<code>innerText</code>设置为等于 <code>innerText</code>，这样就可以去掉所有 HTML 标签.</li>
</ul>
<h2 id="Chapter-12"><a href="#Chapter-12" class="headerlink" title="Chapter 12"></a>Chapter 12</h2><h3 id="12-2"><a href="#12-2" class="headerlink" title="12.2"></a>12.2</h3><ul>
<li>使用<code>ele.style.cssText</code>是最快捷的方法,因为一次能设置多种样式.</li>
<li>使用<code>ele.getPropertyValue(prop)</code>可以得到特定内联样式的值.</li>
<li>最常用来确定浏览器视口大小的方法是<code>document.documentElement.clientWidth</code>.</li>
<li>通过<code>scrollLeft</code>和<code>scrollTop</code>既可以确定元素当前滚动的状态,也可以设置元素的滚动位置</li>
</ul>
<h2 id="Chapter-13"><a href="#Chapter-13" class="headerlink" title="Chapter 13"></a>Chapter 13</h2><h3 id="13-1"><a href="#13-1" class="headerlink" title="13.1"></a>13.1</h3><ul>
<li><p>通过<code>addEventListener()</code>添加的事件处理程序只能使用<code>removeEventListener()</code>来移除；移除时传入的参数与添加处理程序时使用的参数相同。这也意味着通过 <code>addEventListener()</code>添加的匿名函数将无法移除.</p>
</li>
<li><p><code>event.target</code>指向真正触发事件的元素,<code>event.currentTarget</code>始终指向<code>this</code>.</p>
</li>
</ul>
<h3 id="13-5"><a href="#13-5" class="headerlink" title="13.5"></a>13.5</h3><ul>
<li>为了避免导致”空事件处理程序”,最好在卸载页面的时候调用<code>onunload</code>移除所有的事件处理程序.</li>
</ul>
<h2 id="Chapter-17"><a href="#Chapter-17" class="headerlink" title="Chapter 17"></a>Chapter 17</h2><h3 id="17-2"><a href="#17-2" class="headerlink" title="17.2"></a>17.2</h3><ul>
<li><blockquote>
<p>请读者务必要记住，只要代码中包含<code>finally</code>子句，那么无论<code>try</code>还是<code>catch</code>语句块 中的<code>return</code>语句都将被忽略。因此，在使用<code>finally</code>子句之前，一定要非常清楚你想让代码怎么样。</p>
</blockquote>
</li>
<li><p>在<code>throw</code>的时候可以抛出任意类型的值,但是使用内置类型错误,可以更真实的模拟浏览器错误.</p>
</li>
<li><p>可以通过原型继承来自定义错误机制.</p>
</li>
<li><blockquote>
<p>说到抛出错误与捕获错误，我们认为只应该捕获那些你确切地知道该如何处理的错误。捕获错误的<br>目的在于避免浏览器以默认方式处理它们；而抛出错误的目的在于提供错误发生具体原因的消息。</p>
</blockquote>
</li>
<li><blockquote>
<p>任何没有通过<code>try-catch</code>处理的错误都会触发<code>window</code>对象的<code>error</code>事件。只要发生错误，无论是不是浏览器生成的，都会触发<code>error</code>事件，并执行这个事件处理程序。然后，浏览器默认的机制发挥作用，像往常一样显示出错误消息。像下面这样在事件处理程序中返回<code>false</code>，可以阻止浏览器报告错误的默认行为。</p>
</blockquote>
</li>
<li><blockquote>
<p>大体上来说，基本类型的值应该使用<code>typeof</code>来检测，而对象的值则应该使用<code>instanceof</code>来检测。根据使用函数的方式，有时候并不需要逐个检测所有参数的数据类型。但是，面向公众的 API 则必须无条件地执行类型检查，以确保函数始终能够正常地执行。</p>
</blockquote>
</li>
</ul>
<h2 id="Chapter-20"><a href="#Chapter-20" class="headerlink" title="Chapter 20"></a>Chapter 20</h2><h3 id="20-1"><a href="#20-1" class="headerlink" title="20.1"></a>20.1</h3><ul>
<li><blockquote>
<p>关于 JSON，最重要的是要理解它是一种<strong>数据格式，不是一种编程语言</strong>。虽然具有相同的语法形式，<br>但 JSON 并不从属于 JavaScript。而且，并不是只有 JavaScript 才使用 JSON，毕竟 JSON 只是一种数据<br>格式。很多编程语言都有针对 JSON 的解析器和序列化器。</p>
</blockquote>
</li>
<li><p>JSON支持简单值,对象,数组,但是不支持JS的特殊值<code>undefined</code>(毕竟JSON是通用的).</p>
</li>
<li><p>JSON的字符串必须使用双引号.</p>
</li>
<li><p>JSON在描述对象的属性键值对时,必须给属性加双引号.</p>
</li>
<li><blockquote>
<p>对象和数组通常是 JSON 数据结构的最外层形式（当然，这不是强制规定的），利用它们能够创造出各种各样的数据结构。</p>
</blockquote>
</li>
<li><blockquote>
<p>默认情况下， <code>JSON.stringify()</code>输出的 JSON 字符串不包含任何空格字符或缩进，在序列化 JavaScript 对象时，所有函数及原型成员都会被有意忽略，不体现在结果中。此外，值为<code>undefined</code>的任何属性也都会被跳过。结果中最终都是值为有效 JSON 数据类型的实例属性。如果传给 <code>JSON.parse()</code>的字符串不是有效的 JSON，该方法会抛出错误。</p>
</blockquote>
</li>
</ul>
<h2 id="Chapter-24"><a href="#Chapter-24" class="headerlink" title="Chapter 24"></a>Chapter 24</h2><h3 id="24-1"><a href="#24-1" class="headerlink" title="24.1"></a>24.1</h3><ul>
<li><blockquote>
<p>勿将<code>event</code>对象传给其他方法；只传来自<code>event</code>对象中所需的数据；</p>
<p>任何可以在应用层面的动作都应该可以在不执行任何事件处理程序的情况下进行；</p>
<p>任何事件处理程序都应该处理事件，然后将处理转交给应用逻辑。</p>
</blockquote>
</li>
<li><blockquote>
<p>如果看到了与 null 比较的代码，尝试使用以下技术替换：</p>
<ul>
<li>如果值应为一个引用类型，使用<code>instanceof</code>操作符检查其构造函数；</li>
</ul>
<ul>
<li>如果值应为一个基本类型，使用<code>typeof</code>检查其类型；</li>
<li>如果是希望对象包含某个特定的方法名，则使用<code>typeof</code>操作符确保指定名字的方法存在于对</li>
</ul>
<p>象上。</p>
</blockquote>
</li>
<li><blockquote>
<p> 用户界面字符串 —— 任何用于显示给用户的字符串，都应被抽取出来以方便国际化。</p>
</blockquote>
</li>
</ul>
<h3 id="24-2"><a href="#24-2" class="headerlink" title="24.2"></a>24.2</h3><ul>
<li><blockquote>
<p>避免全局查找</p>
</blockquote>
<p>比如如果需要多次引用<code>document.getElementById()</code>就可以在局部作用域中使用<code>var doc = document</code>来减少在作用域链上的查找.</p>
</li>
<li><blockquote>
<p>和函数类似， <code>with</code>语句会创建自己的作用域，因此会增加其中执行的代码的作用域链的长度。由于额外的作用域链查找，在 with 语句中执行的代码肯定会比外面执行的代码要慢。</p>
</blockquote>
</li>
<li><p>访问对象的属性是一个O(n)复杂度的操作,所以最好是声明一个变量进行引用.</p>
</li>
<li><blockquote>
<p>如果有一系列复杂的 if-else 语句，可以转换成单个<code>switch</code>语句则可以得到更快的代码。</p>
</blockquote>
</li>
<li><blockquote>
<p>对于大的 DOM 更改，使用<code>innerHTML</code>比使用标准 DOM 方法创建同样的 DOM 结构快得多。当把innerHTML 设置为某个值时，后台会创建一个 HTML 解析器，然后使用内部的 DOM 调用来创建 DOM 结构，而非基于 JavaScript 的 DOM 调用。由于内部方法是编译好的而非解释执行的，所以执行快得多。</p>
</blockquote>
</li>
<li><blockquote>
<p>任何时候要访问<code>HTMLCollection</code>，不管它是一个属性还是一个方法，都是在文档上进行一个查询，这个查询开销很昂贵。最小化访问<code>HTMLCollection</code>的次数可以极大地改进脚本的性能。</p>
</blockquote>
</li>
</ul>
</div></article></div></main><footer><div class="paginator"><a class="prev" href="/2017-06-06/HTML5大纲及计算方法/">prev</a><a class="next" href="/2017-02-07/float理解/">next</a></div><div id="lv-container" data-id="city" data-uid="MTAyMC8yODQyOS81MDAw"><script type="text/javascript">(function(d, s) {
var j, e = d.getElementsByTagName(s)[0];

if (typeof LivereTower === 'function') { return; }

j = d.createElement(s);
j.src = 'https://cdn-city.livere.com/js/embed.dist.js';
j.async = true;

e.parentNode.insertBefore(j, e);
})(document, 'script');</script></div><noscript>为正常使用来必力评论功能请激活JavaScript</noscript><div class="copyright"><p>&copy; 2017 <a href="https://fi3ework.github.io">Wee</a>.<br>Powered by <a href="https://hexo.io/" target="_blank">Hexo</a> &  <a href="https://github.com/fi3ework/hexo-theme-archer" target="_blank">Ares</a>.</p></div></footer></div></body></html>